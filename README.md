# PruebaTecnicaLinktic

Sistema de microservicios para gesti√≥n de productos e inventario.

## üèóÔ∏è Arquitectura

El proyecto est√° compuesto por:

- **PostgreSQL**: Base de datos relacional (Puerto 5432)
- **Products Service**: Microservicio de gesti√≥n de productos (Puerto 8080)
- **Inventory Service**: Microservicio de gesti√≥n de inventario (Puerto 8081)
- **Product Management Service**: Aplicaci√≥n web Angular para gesti√≥n de productos (Puerto 4200)

### üî∑ Arquitectura Hexagonal (Ports & Adapters)

Ambos microservicios implementan **Arquitectura Hexagonal**, tambi√©n conocida como **Ports and Adapters**, propuesta por Alistair Cockburn. Esta arquitectura separa la l√≥gica de negocio del c√≥digo de infraestructura.

#### ¬øPor qu√© Arquitectura Hexagonal?

1. **Independencia de Frameworks**: La l√≥gica de negocio no depende de Spring, JPA u otros frameworks
2. **Testabilidad**: Facilita las pruebas unitarias al aislar la l√≥gica de negocio
3. **Flexibilidad**: Permite cambiar implementaciones (base de datos, APIs externas) sin afectar el dominio
4. **Mantenibilidad**: C√≥digo m√°s limpio y organizado con responsabilidades bien definidas
5. **Escalabilidad**: Facilita la evoluci√≥n y crecimiento del sistema

#### Estructura de Capas

```
üì¶ Microservicio
‚îú‚îÄ‚îÄ üéØ Domain (N√∫cleo - L√≥gica de Negocio)
‚îÇ   ‚îú‚îÄ‚îÄ model/          # Entidades del dominio
‚îÇ   ‚îú‚îÄ‚îÄ port/           # Interfaces (Puertos)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ in/         # Casos de uso (entrada)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ out/        # Repositorios (salida)
‚îÇ   ‚îî‚îÄ‚îÄ exception/      # Excepciones del dominio
‚îÇ
‚îú‚îÄ‚îÄ üîß Application (Casos de Uso)
‚îÇ   ‚îî‚îÄ‚îÄ service/        # Implementaci√≥n de casos de uso
‚îÇ
‚îî‚îÄ‚îÄ üîå Infrastructure (Adaptadores)
    ‚îú‚îÄ‚îÄ persistence/    # Adaptadores de BD (JPA)
    ‚îú‚îÄ‚îÄ web/           # Adaptadores REST (Controllers)
    ‚îú‚îÄ‚îÄ security/      # Seguridad (API Keys)
    ‚îú‚îÄ‚îÄ client/        # Clientes HTTP externos
    ‚îî‚îÄ‚îÄ aop/           # Aspectos (Logging)
```

**Flujo de Datos:**
```
Cliente HTTP ‚Üí Controller (Adapter) ‚Üí Use Case (Application) ‚Üí Domain Logic ‚Üí Repository Port ‚Üí JPA Adapter ‚Üí PostgreSQL
```

### üé® Patrones de Dise√±o Implementados

#### 1. **Repository Pattern**
- **Ubicaci√≥n**: `domain/port/out/` y `infrastructure/persistence/adapter/`
- **Prop√≥sito**: Abstrae el acceso a datos, separando la l√≥gica de persistencia del dominio
- **Beneficio**: Permite cambiar la implementaci√≥n de persistencia sin afectar la l√≥gica de negocio

```java
// Puerto (Interfaz en el dominio)
public interface ProductRepository {
    Product save(Product product);
    Optional<Product> findById(Long id);
}

// Adaptador (Implementaci√≥n en infraestructura)
@Component
public class ProductRepositoryAdapter implements ProductRepository {
    // Implementaci√≥n con JPA
}
```

#### 2. **Dependency Injection (IoC)**
- **Framework**: Spring Boot
- **Prop√≥sito**: Inversi√≥n de control para gestionar dependencias
- **Beneficio**: Bajo acoplamiento y alta cohesi√≥n

#### 3. **DTO Pattern (Data Transfer Object)**
- **Ubicaci√≥n**: `infrastructure/web/dto/`
- **Prop√≥sito**: Objetos para transferir datos entre capas
- **Beneficio**: Desacopla la representaci√≥n externa de los modelos del dominio

#### 4. **Mapper Pattern**
- **Ubicaci√≥n**: `infrastructure/web/mapper/` y `infrastructure/persistence/mapper/`
- **Prop√≥sito**: Convierte entre DTOs, entidades JPA y modelos del dominio
- **Beneficio**: Separaci√≥n clara entre capas

#### 5. **Use Case Pattern**
- **Ubicaci√≥n**: `domain/port/in/` y `application/service/`
- **Prop√≥sito**: Encapsula la l√≥gica de negocio en casos de uso espec√≠ficos
- **Beneficio**: C√≥digo m√°s legible y mantenible

#### 6. **Adapter Pattern**
- **Ubicaci√≥n**: `infrastructure/persistence/adapter/`, `infrastructure/web/client/`
- **Prop√≥sito**: Adapta interfaces externas a las interfaces del dominio
- **Beneficio**: Flexibilidad para cambiar implementaciones

#### 7. **Aspect-Oriented Programming (AOP)**
- **Ubicaci√≥n**: `infrastructure/aop/LoggingAspect.java`
- **Prop√≥sito**: Logging transversal sin contaminar la l√≥gica de negocio
- **Beneficio**: Separaci√≥n de concerns (preocupaciones cruzadas)

```java
@Aspect
@Component
public class LoggingAspect {
    @Around("execution(* com.example..application.service.*.*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) {
        // Logging autom√°tico
    }
}
```

#### 8. **Strategy Pattern**
- **Ubicaci√≥n**: Validaciones y reglas de negocio
- **Prop√≥sito**: Permite diferentes algoritmos de validaci√≥n
- **Beneficio**: Extensibilidad sin modificar c√≥digo existente

#### 9. **Builder Pattern**
- **Uso**: Con Lombok `@Builder` en DTOs y entidades
- **Prop√≥sito**: Construcci√≥n fluida de objetos complejos
- **Beneficio**: C√≥digo m√°s legible y mantenible

#### 10. **Filter Pattern**
- **Ubicaci√≥n**: `infrastructure/security/ApiKeyAuthenticationFilter.java`
- **Prop√≥sito**: Intercepta requests para validar API Keys
- **Beneficio**: Seguridad centralizada

### üêò ¬øPor qu√© PostgreSQL?

Elegimos **PostgreSQL** como base de datos por las siguientes razones:

#### Ventajas T√©cnicas

1. **ACID Compliance**: Garantiza transacciones confiables y consistencia de datos
2. **Relaciones Complejas**: Soporte robusto para relaciones entre productos, inventario y compras
3. **Integridad Referencial**: Foreign keys y constraints para mantener la integridad de datos
4. **Rendimiento**: Excelente rendimiento en operaciones de lectura y escritura
5. **Escalabilidad**: Soporta grandes vol√∫menes de datos y concurrencia

#### Caracter√≠sticas Espec√≠ficas

- **JSON Support**: Permite almacenar datos semi-estructurados si es necesario
- **√çndices Avanzados**: B-tree, Hash, GiST, GIN para optimizar consultas
- **Transacciones**: Esencial para operaciones de compra que afectan inventario
- **Open Source**: Sin costos de licenciamiento
- **Comunidad Activa**: Amplia documentaci√≥n y soporte

#### Casos de Uso en el Proyecto

```sql
-- Ejemplo: Transacci√≥n at√≥mica en compras
BEGIN;
  UPDATE inventory SET quantity = quantity - 5 WHERE product_id = 1;
  INSERT INTO purchase (product_id, quantity, purchase_date) VALUES (1, 5, NOW());
COMMIT;
```

- **Products Service**: Gesti√≥n CRUD de productos con validaciones
- **Inventory Service**: Control de stock con transacciones at√≥micas
- **Purchase Service**: Registro de compras con integridad referencial

### üîê Principios SOLID Aplicados

- **S** - Single Responsibility: Cada clase tiene una √∫nica responsabilidad
- **O** - Open/Closed: Abierto para extensi√≥n, cerrado para modificaci√≥n
- **L** - Liskov Substitution: Los adaptadores pueden sustituirse sin romper el sistema
- **I** - Interface Segregation: Interfaces espec√≠ficas (ports) en lugar de gen√©ricas
- **D** - Dependency Inversion: Dependemos de abstracciones (ports), no de implementaciones

## üöÄ Inicio R√°pido

### Prerrequisitos

- Docker Desktop instalado y en ejecuci√≥n
- Docker Compose v3.9 o superior

### Ejecutar el Sistema Completo

1. **Clonar el repositorio** (si a√∫n no lo has hecho):
```bash
git clone https://github.com/Camilomora117/PruebaTecnicaLinktic
cd PruebaTecnicaLinktic
```

2. **Iniciar todos los servicios**:
```bash
docker-compose up -d
```

Este comando:
- Construir√° las im√°genes Docker de los microservicios
- Iniciar√° PostgreSQL con los scripts de inicializaci√≥n
- Desplegar√° ambos microservicios
- Configurar√° la red interna entre servicios

3. **Verificar el estado de los servicios**:
```bash
docker-compose ps
```

4. **Ver los logs**:
```bash
# Todos los servicios
docker-compose logs -f

# Solo un servicio espec√≠fico
docker-compose logs -f products-service
docker-compose logs -f inventory-service
docker-compose logs -f postgres
```

## üì° Endpoints Disponibles

### Product Management Service (Puerto 4200)
- **URL**: `http://localhost:4200`
- **Descripci√≥n**: Interfaz web Angular para gestionar productos e inventario
- **Caracter√≠sticas**:
  - Interfaz de usuario moderna con Angular Material
  - Gesti√≥n completa de productos (CRUD)
  - Visualizaci√≥n y actualizaci√≥n de inventario
  - Procesamiento de compras
  - Comunicaci√≥n con los microservicios backend

### Products Service (Puerto 8080)
- **API Base**: `http://localhost:8080`
- **Swagger UI**: `http://localhost:8080/swagger-ui/index.html`
- **API Docs**: `http://localhost:8080/v3/api-docs`

#### Ejemplos de Curl - Products Service

**1. Crear un Producto (POST)**
```bash
curl -X POST http://localhost:8080/products \
  -H "Content-Type: application/json" \
  -H "X-API-Key: products-api-key-123" \
  -d '{
    "name": "Laptop Dell XPS 15",
    "price": 1299.99,
    "description": "Laptop de alto rendimiento con procesador Intel i7"
  }'
```

**2. Obtener Todos los Productos (GET)**
```bash
curl -X GET http://localhost:8080/products \
  -H "X-API-Key: products-api-key-123"
```

**3. Obtener un Producto por ID (GET)**
```bash
curl -X GET http://localhost:8080/products/1 \
  -H "X-API-Key: products-api-key-123"
```

**4. Actualizar un Producto (PUT)**
```bash
curl -X PUT http://localhost:8080/products/1 \
  -H "Content-Type: application/json" \
  -H "X-API-Key: products-api-key-123" \
  -d '{
    "name": "Laptop Dell XPS 15 (Actualizado)",
    "price": 1199.99,
    "description": "Laptop de alto rendimiento con descuento especial"
  }'
```

**5. Eliminar un Producto (DELETE)**
```bash
curl -X DELETE http://localhost:8080/products/1 \
  -H "X-API-Key: products-api-key-123"
```

---

### Inventory Service (Puerto 8081)
- **API Base**: `http://localhost:8081`
- **Swagger UI**: `http://localhost:8081/swagger-ui/index.html`
- **API Docs**: `http://localhost:8081/v3/api-docs`

#### Ejemplos de Curl - Inventory Service

**1. Obtener Inventario de un Producto (GET)**
```bash
curl -X GET http://localhost:8081/inventory/1 \
  -H "X-API-Key: inventory-api-key-123"
```

**2. Actualizar Cantidad de Inventario (PUT)**
```bash
curl -X PUT http://localhost:8081/inventory/1 \
  -H "Content-Type: application/json" \
  -H "X-API-Key: inventory-api-key-123" \
  -d '{
    "quantity": 50
  }'
```

**3. Procesar una Compra (POST)**
```bash
curl -X POST http://localhost:8081/purchase \
  -H "Content-Type: application/json" \
  -H "X-API-Key: inventory-api-key-123" \
  -d '{
    "productId": 1,
    "quantity": 5
  }'
```

---

### Base de Datos PostgreSQL
- **Host**: `localhost`
- **Puerto**: `5432`
- **Database**: `testdb`
- **Usuario**: `testuser`
- **Contrase√±a**: `testpassword`

**Conectar a PostgreSQL con psql:**
```bash
docker-compose exec postgres psql -U testuser -d testdb
```

## üîë API Keys

Los servicios est√°n protegidos con API Keys:

- **Products Service**: `products-api-key-123`
- **Inventory Service**: `inventory-api-key-123`

Incluye el header en tus peticiones:
```
X-API-Key: products-api-key-123
```

## üéØ Flujo de Trabajo Completo (Ejemplo)

Aqu√≠ hay un ejemplo de flujo completo para crear un producto, gestionar su inventario y procesar una compra:

```bash
# 1. Crear un producto
curl -X POST http://localhost:8080/products \
  -H "Content-Type: application/json" \
  -H "X-API-Key: products-api-key-123" \
  -d '{
    "name": "Mouse Gaming RGB",
    "price": 49.99,
    "description": "Mouse gaming con iluminaci√≥n RGB y 7 botones programables"
  }'

# Respuesta esperada: {"id":1,"name":"Mouse Gaming RGB","price":49.99,"description":"..."}

# 2. Actualizar el inventario del producto (ID 1)
curl -X PUT http://localhost:8081/inventory/1 \
  -H "Content-Type: application/json" \
  -H "X-API-Key: inventory-api-key-123" \
  -d '{
    "quantity": 100
  }'

# 3. Consultar el inventario actual
curl -X GET http://localhost:8081/inventory/1 \
  -H "X-API-Key: inventory-api-key-123"

# 4. Procesar una compra de 3 unidades
curl -X POST http://localhost:8081/purchase \
  -H "Content-Type: application/json" \
  -H "X-API-Key: inventory-api-key-123" \
  -d '{
    "productId": 1,
    "quantity": 3
  }'

# 5. Verificar el inventario actualizado (deber√≠a ser 97)
curl -X GET http://localhost:8081/inventory/1 \
  -H "X-API-Key: inventory-api-key-123"
```

## üõ†Ô∏è Comandos √ötiles

### Detener todos los servicios
```bash
docker-compose down
```

### Detener y eliminar vol√∫menes (limpieza completa)
```bash
docker-compose down -v
```

### Reconstruir las im√°genes
```bash
docker-compose build --no-cache
```

### Reiniciar un servicio espec√≠fico
```bash
docker-compose restart products-service
```

### Ejecutar comandos dentro de un contenedor
```bash
# Acceder a la base de datos
docker-compose exec postgres psql -U testuser -d testdb

# Ver logs en tiempo real de un servicio
docker-compose logs -f inventory-service
```

## üìÅ Estructura del Proyecto

```
PruebaTecnicaLinktic/
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îî‚îÄ‚îÄ init/                          # Scripts SQL de inicializaci√≥n
‚îÇ       ‚îú‚îÄ‚îÄ script_sql_products.sql
‚îÇ       ‚îú‚îÄ‚îÄ script_sql_inventory.sql
‚îÇ       ‚îî‚îÄ‚îÄ script_sql_purchase.sql
‚îú‚îÄ‚îÄ project-root/
‚îÇ   ‚îú‚îÄ‚îÄ products-service/              # Microservicio de productos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ .dockerignore
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pom.xml
‚îÇ   ‚îú‚îÄ‚îÄ inventory-service/             # Microservicio de inventario
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ .dockerignore
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pom.xml
‚îÇ   ‚îî‚îÄ‚îÄ product-management-service/    # Aplicaci√≥n web Angular
‚îÇ       ‚îú‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ       ‚îú‚îÄ‚îÄ .dockerignore
‚îÇ       ‚îú‚îÄ‚îÄ nginx.conf
‚îÇ       ‚îú‚îÄ‚îÄ package.json
‚îÇ       ‚îî‚îÄ‚îÄ angular.json
‚îú‚îÄ‚îÄ docker-compose.yml                 # Orquestaci√≥n de servicios
‚îî‚îÄ‚îÄ README.md
```

## üîß Desarrollo Local

Si deseas ejecutar los servicios localmente sin Docker:

1. **Iniciar PostgreSQL**:
```bash
docker-compose up -d postgres
```

2. **Ejecutar Products Service**:
```bash
cd project-root/products-service
mvn spring-boot:run
```

3. **Ejecutar Inventory Service**:
```bash
cd project-root/inventory-service
mvn spring-boot:run
```

## üêõ Troubleshooting

### Los servicios no inician
- Verifica que Docker Desktop est√© en ejecuci√≥n
- Aseg√∫rate de que los puertos 5432, 8080, 8081 y 4200 no est√©n en uso
- Revisa los logs: `docker-compose logs`

### Error de conexi√≥n a la base de datos
- Espera unos segundos m√°s, PostgreSQL tarda en inicializar
- Verifica el health check: `docker-compose ps`

### Reconstruir desde cero
```bash
docker-compose down -v
docker-compose build --no-cache
docker-compose up -d
```

## üìù Notas

- Los microservicios esperan a que PostgreSQL est√© completamente iniciado gracias al `healthcheck`
- El `inventory-service` depende del `products-service` y esperar√° a que este inicie
- El `product-management-service` (frontend Angular) depende de ambos servicios backend y esperar√° a que inicien
- Los datos de la base de datos persisten en un volumen Docker
- Los Dockerfiles usan multi-stage builds para optimizar el tama√±o de las im√°genes
- El frontend Angular se sirve a trav√©s de nginx en el puerto 4200
- Nginx est√° configurado como proxy inverso para las APIs de los microservicios